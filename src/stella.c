/* stella.c

  Copyright 1995, 2023 by Adam Roach
  See LICENSE file for licensing terms

*/

#include "2600.h"
#include "stella.h"
#include "riot.h"
#include "graphics.h"
#include "io.h"

unsigned int stella_rasterline, stella_clock; /* Global -- visible to 6507.c */
unsigned int start_clock, end_clock;

char framerate = 1;
char frame = 0;
char invbl = 0;

unsigned char pf0, pf1, pf2;
unsigned char ctrlpf;
unsigned char nusiz0, nusiz1;
unsigned char resmp0, resmp1;
         char hmp0, hmp1, hmm0, hmm1, hmbl;
unsigned char enam0, enam1, enabl;
unsigned char grp0, grp1;
unsigned char refp0, refp1;
unsigned char vdelp0, vdelp1, vdelbl;
unsigned char colup0, colup1, colupf, colubk;

unsigned char audf0, audf1;
unsigned char audc0, audc1;
unsigned char audv0, audv1;

unsigned char cxm0p, cxm1p, cxp0fb, cxp1fb, cxm0fb, cxm1fb, cxblpf, cxppmm;

unsigned char p0x, p1x, m0x, m1x, bx; /* x coordinates */

unsigned char line[160];

int temp;
unsigned char raster_pos;

unsigned char length[8] = {8,24,40,40,72,16,72,32};

unsigned char player[2][8][72] =
  /* not mirrored */
{{{0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01}, /* one copy */
  {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,  /* two, close */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01},
  {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,  /* two, medium */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01},
  {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,  /* three, close */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01},
  {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,  /* two, far */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01},
  {0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10,  /* double width */
   0x08,0x08,0x04,0x04,0x02,0x02,0x01,0x01},
  {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,  /* three, medium */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01},
  {0x80,0x80,0x80,0x80,0x40,0x40,0x40,0x40,  /* quad width */
   0x20,0x20,0x20,0x20,0x10,0x10,0x10,0x10,
   0x08,0x08,0x08,0x08,0x04,0x04,0x04,0x04,
   0x02,0x02,0x02,0x02,0x01,0x01,0x01,0x01}},

   /* mirrored */
 {{0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80}, /* one copy */
  {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,  /* two, close */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80},
  {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,  /* two, medium */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80},
  {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,  /* three, close */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80},
  {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,  /* two, far */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80},
  {0x01,0x01,0x02,0x02,0x04,0x04,0x08,0x08,  /* double width */
   0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80},
  {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,  /* three, medium */
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80},
  {0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x02,  /* quad width */
   0x04,0x04,0x04,0x04,0x08,0x08,0x08,0x08,
   0x10,0x10,0x10,0x10,0x20,0x20,0x20,0x20,
   0x40,0x40,0x40,0x40,0x80,0x80,0x80,0x80}}};

BYTE4 field[2][40]=
  {{0x00100000,0x00200000,0x00400000,0x00800000, /* non-mirrored */
    0x00008000,0x00004000,0x00002000,0x00001000,
    0x00000800,0x00000400,0x00000200,0x00000100,
    0x00000001,0x00000002,0x00000004,0x00000008,
    0x00000010,0x00000020,0x00000040,0x00000080,
    0x00100000,0x00200000,0x00400000,0x00800000,
    0x00008000,0x00004000,0x00002000,0x00001000,
    0x00000800,0x00000400,0x00000200,0x00000100,
    0x00000001,0x00000002,0x00000004,0x00000008,
    0x00000010,0x00000020,0x00000040,0x00000080},
   {0x00100000,0x00200000,0x00400000,0x00800000, /* mirrored */
    0x00008000,0x00004000,0x00002000,0x00001000,
    0x00000800,0x00000400,0x00000200,0x00000100,
    0x00000001,0x00000002,0x00000004,0x00000008,
    0x00000010,0x00000020,0x00000040,0x00000080,
    0x00000080,0x00000040,0x00000020,0x00000010,
    0x00000008,0x00000004,0x00000002,0x00000001,
    0x00000100,0x00000200,0x00000400,0x00000800,
    0x00001000,0x00002000,0x00004000,0x00008000,
    0x00800000,0x00400000,0x00200000,0x00100000}};

unsigned char hmtable[16] ={ 0,  1,  2,  3,  4,  5,  6,  7,
                            -8, -7, -6, -5, -4, -3, -2, -1};


void init_stella(){
  unsigned char i,j;
  init_graphics();
  start_clock = stella_rasterline = stella_clock = 0;
  p0x = p1x = m0x = m1x = bx = 0;
}

void setframerate(char rate){
  framerate = rate;
}

void check_collisions(){
  int i;
  char pfmirror = ctrlpf&1;
  BYTE4 pfpattern = ((BYTE4)pf0<<16)|((BYTE4)pf1<<8)|((BYTE4)pf2);
  char p0, p1, m0, m1, pf, bl;
#define COLLISION(a1,a2,b1,b2) ((a1&&a2)?64:0)|((b1&&b2)?128:0);
  for (i = start_clock; i<end_clock; i++){
    p0=(i>p0x && i<p0x + length [nusiz0 & 0x7] &&
        (grp0 & player[refp0][nusiz0&0x7][i-p0x]));
    p1=(i>p1x && i<p1x + length [nusiz1 & 0x7] &&
        (grp1 & player[refp1][nusiz1&0x7][i-p1x]));
    m0 = (enam0 && i>m0x && (i < m0x+(0x01<<((nusiz0>>4)&0x03))));
    m1 = (enam1 && i>m1x && (i < m1x+(0x01<<((nusiz1>>4)&0x03))));
    bl = (enabl && i>bx && (i < bx+(0x01<<((ctrlpf>>4)&0x03))));
    pf = (pfpattern & field[pfmirror][i>>2]);
    cxm0p  |= COLLISION(m0, p1, m0, p0);
    cxm1p  |= COLLISION(m1, p1, m1, p0);
    cxp0fb |= COLLISION(p0, pf, p0, bl);
    cxp1fb |= COLLISION(p1, pf, p1, bl);
    cxm0fb |= COLLISION(m0, pf, m0, bl);
    cxm1fb |= COLLISION(m1, pf, m1, bl);
    cxblpf |= COLLISION(bl, pf,  0,  0);
    cxppmm |= COLLISION(p0, p1, m0, m1);
  }
}

/* The draw routines will update the line[] array from start_clock
   to end_clock for line number stella_rasterline */

void dbk(){
  int i;
  for (i=start_clock; i<end_clock; i++) line[i] = colubk;
}

void draw_missle (unsigned char x, unsigned char color, unsigned char size,
                  unsigned char active){
  unsigned int i, start, end;
  if(!active) return;
  start = x;
  end   = x+(0x01<<(size&0x03));
  if(start_clock > end || end_clock < start) return;
  if(start_clock > start) start = start_clock;
  if(end_clock < end) end = end_clock;
  for (i=start; i < end; i++) line[i] = color;
}

void draw_player (int x, unsigned char color, unsigned char size,
                  unsigned char mirror, unsigned char image){
  int i, start, end;

  if(image == 0) return;
  if (x >= 160) x -= 228;
  size &= 0x07;
  start = x;
  end   = x+length[size];
  if(start_clock > end || end_clock < start) return;
  if(start_clock > start) start = start_clock;
  if(end_clock < end) end = end_clock;
  for (i=start; i < end; i++)
    if(image & player[mirror][size][i-x]) line[i] = color;
}

void dpf(){
  int i;
  char mirror = ctrlpf&1;
  BYTE4 pattern = ((BYTE4)pf0<<16)|((BYTE4)pf1<<8)|((BYTE4)pf2);
  BYTE4 *pf_line = (BYTE4 *)line;
  char pf_end = (end_clock>>2);
  BYTE4 fg;

  if (ctrlpf&2){
    if (start_clock<80) fg = ((BYTE4)colup0<<24)|((BYTE4)colup0<<16)|
                             ((BYTE4)colup0<<8)|(BYTE4)colup0;
    else fg=((BYTE4)colup1<<24)|((BYTE4)colup1<<16)|
            ((BYTE4)colup1<<8)|(BYTE4)colup1;
    for (i=(start_clock>>2); i<pf_end; i++){
      if (i == 20) fg = ((BYTE4)colup1<<24)|((BYTE4)colup1<<16)|
                        ((BYTE4)colup1<<8)|(BYTE4)colup1;
      if(pattern & field[mirror][i]) pf_line[i] = fg;
    }
  } else {
  /* Yes, this is redundant, but it allows us to check for ctrlpf bit 2
     only once, instead of for each pixel. The profiler shows that this
     routine tops all non-graphics routines otherwise. */
    fg = ((BYTE4)colupf<<24)|((BYTE4)colupf<<16)|
         ((BYTE4)colupf<<8)|(BYTE4)colupf;
    for (i=(start_clock>>2); i<pf_end; i++){
      if(pattern & field[mirror][i]) pf_line[i] = fg;
    }
  }
}

void draw_raster(){
  if (frame || invbl) return;
  end_clock = stella_clock; if(end_clock>=160) end_clock=160;
  dbk();
  if (!(ctrlpf & 4)){
    dpf();
    draw_missle(bx,colupf,ctrlpf>>4,enabl); /* ball */
  }
  draw_player(p1x,colup1,nusiz1&7,refp1,grp1);   /* player 1 */
  draw_missle(m1x,colup1,nusiz1>>4,enam1);       /* missle 1 */
  draw_player(p0x,colup0,nusiz0&7,refp0,grp0);   /* player 0 */
  draw_missle(m0x,colup0,nusiz0>>4,enam0);       /* missle 0 */
  if (ctrlpf & 4){
    dpf();
    draw_missle(bx,colupf,ctrlpf>>4,enabl); /* ball */
  }
/*  check_collisions(); */
  start_clock = stella_clock; /* setup for next time */

  if(start_clock>=228) {
    start_clock=0;
    plot_raster(line,stella_rasterline);
  }
}

void stella_cycle(unsigned int numcycles){
  stella_clock += numcycles;
  if(stella_clock >= 228){
    if(stella_rasterline <= 200){
      draw_raster();
    }
    stella_rasterline += (stella_clock/228);
    stella_clock %= 228;
  }
  if(stella_rasterline >= 262){
    stella_rasterline=0;
  }
}

unsigned char stella_read(unsigned int address){
  getio();
  switch(address){
    case 0x00: return cxm0p;  /* Collision: m0 & p */
    case 0x01: return cxm1p;  /* Collision: m1 & p */
    case 0x02: return cxp0fb; /* Collision: p0 & b/pf */
    case 0x03: return cxp1fb; /* Collision: p1 & b/pf */
    case 0x04: return cxm0fb; /* Collision: m0 & b/pf */
    case 0x05: return cxm1fb; /* Collision: m1 & b/pf */
    case 0x06: return cxblpf; /* Collision: bl & pf */
    case 0x07: return cxppmm; /* Collision: p0 & p1, m0 & m1 */
    case 0x08: return 0x00; /* Read pot 0 */
    case 0x09: return 0x00; /* Read pot 1 */
    case 0x0A: return 0x00; /* Read pot 2 */
    case 0x0B: return 0x00; /* Read pot 3 */
    case 0x0C: return fire1; /* Read trigger 0 */
    case 0x0D: return fire2; /* Read trigger 1 */
  }
  return(0);
}

void stella_write(unsigned int address, unsigned char value){
  unsigned char sprite_pos;
  draw_raster();
  if(address >= 0x10 && address <= 0x14){
    sprite_pos = stella_clock;
  }
  switch(address){
    case 0x00: /* vertical sync -- we sync off vbl mainly, but just in case */
      if (!(value & 0x02)){
        stella_rasterline = 201-201;
      }
      break;
    case 0x01: /* vertical blank -- begin new frame at end of vblank */
      if (!(value & 0x02)){
        invbl = 0;
        frame++; frame %= framerate;
        stella_rasterline = 0; /* wraps at 262 */
      } else {
        invbl = 1;
      }
      break;
    case 0x02: /* WSYNC -- wait for horizontal sync */
      if(stella_clock <= 160+5){
        temp = 160+5-stella_clock;      /* idle until this line's hblank */
      } else {
        temp = (160+5+228)-stella_clock;  /* idle until next line's hblank */
      }
      riot_cycle(temp);
      stella_cycle(temp);
      break;
    case 0x03: /* RSYNC -- reset horizontal sync */
      /* reset_screen();
      printf("RSYNC signal should be used for testing only...\n");
      die(); */
      stella_clock = 160;
      break;
    case 0x04: nusiz0 = value; break;
    case 0x05: nusiz1 = value; break;
    case 0x06: colup0 = value; break;
    case 0x07: colup1 = value; break;
    case 0x08: colupf = value; break;
    case 0x09: colubk = value; break;
    case 0x0A: ctrlpf = value; break;
    case 0x0B: refp0  = (value&0x08)?1:0; break;
    case 0x0C: refp1  = (value&0x08)?1:0; break;
    case 0x0D: pf0    = value; break;
    case 0x0E: pf1    = value; break;
    case 0x0F: pf2    = value; break;

    /* Actual x postion of raster line when the write occurs will be
       sometime in the last cycle of the write opcode. (Actually, in
       many cases, it occurs *both* in the second-to-last *and* last
       cycles. I don't know how a real stella handles these rapid
       writes. */

    case 0x10: p0x = sprite_pos; break;
    case 0x11: p1x = sprite_pos; break;
    case 0x12: m0x = sprite_pos; break;
    case 0x13: m1x = sprite_pos; break;
    case 0x14: bx  = sprite_pos; break;

    case 0x15: audc0  = value; break;
    case 0x16: audc1  = value; break;
    case 0x17: audf0  = value; break;
    case 0x18: audf1  = value; break;
    case 0x19: audv0  = value; break;
    case 0x1A: audv1  = value; break;

    case 0x1B: grp0   = value; break;
    case 0x1C: grp1   = value; break;
    case 0x1D: enam0  = value; break;
    case 0x1E: enam1  = value; break;
    case 0x1F: enabl  = value; break;

    case 0x20: hmp0   = hmtable[(value>>4)&0x0F]; break;
    case 0x21: hmp1   = hmtable[(value>>4)&0x0F]; break;
    case 0x22: hmm0   = hmtable[(value>>4)&0x0F]; break;
    case 0x23: hmm1   = hmtable[(value>>4)&0x0F]; break;
    case 0x24: hmbl   = hmtable[(value>>4)&0x0F]; break;

    case 0x25: vdelp0 = value; break;
    case 0x26: vdelp1 = value; break;
    case 0x27: vdelbl = value; break;
    case 0x28: resmp0 = value; break;
    case 0x29: resmp1 = value; break;
    case 0x2A: if (stella_clock >= 160){
                 p0x -= hmp0; p1x -= hmp1; m0x -= hmm0; m1x -= hmm1;
                 bx  -= hmbl;
               }
               break;
    case 0x2B: hmp0 = hmp1 = hmm0 = hmm1 = hmbl = 0; break;
    case 0x2C: cxm0p=cxm1p=cxp0fb=cxp1fb=cxm0fb=cxm1fb=cxblpf=cxppmm=0;
               break;
  }
}

